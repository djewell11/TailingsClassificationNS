//Get Sentinel-2 bands according to resolution
//10m bands
var bands10 = ["B2", "B3", "B4", "B8"];
 
//20m bands
var bands20 = ["B2", "B3", "B4", "B5", "B6", "B7", "B8", "B8A", "B11", "B12"];

//Get a cloud-free image from summer, 2020
var trainingImage = ee.Image(s2sr
  .filterBounds(ROI)
  .filterDate("2020-06-01", "2020-08-30")
  .sort("CLOUDY_PIXEL_PERCENTAGE")
  .first());
  // .select(bands10);

//Add filtered S2 image to map
// Map.centerObject(ROI, 13);
Map.addLayer(trainingImage, {bands:["B4", "B3", "B2"], min:300, max:2500}, "Sentinel-2 SR", false);

//Move "target" point on map to find another image
var targetImage = ee.Image(s2sr
  .filterBounds(target)
  .filterDate("2020-06-01", "2020-08-30")
  .sort("CLOUDY_PIXEL_PERCENTAGE")
  .first());

//Points of mine districts for reference
var districts = ee.FeatureCollection(districtPoints);

//Bring in tailings for later validation and clean up
var tailings = ee.FeatureCollection(tailingsNS);

//Clip to mainland
var tailings = tailings.map(function(feature)
    {return feature.intersection(mainlandNS)}
  );
  
  
//Show tailings table
// print(tailings);


//Filter to only gold and only tailings_areas
//Crushers with no associated tailings areas are coded as Crusher1 = 0. Filter those out
var tailings = tailings.filter(ee.Filter.eq("Commodity", "Gold"))
  .filter(ee.Filter.eq("GCODE", "TAILINGS_AREA"))
  .filter(ee.Filter.neq("Crusher1", "0"));

//Add watershed polygons
// var watersheds = ee.FeatureCollection(watershedTable).map(function(feature)
//     {return feature.intersection(mainlandNS)}
//   ).style({fillColor: "#00000000"});

////////////////////////////////////////////////////////////////////
///                                                              ///
///                 Dryest Pixel Moasic                          ///
///                                                              ///
////////////////////////////////////////////////////////////////////

//Create a mosaic of the lowest NDWI pixels across a timespan

// var targetRange = ee.ImageCollection(s2sr
//   .filterBounds(ROI)
//   .filterDate("2016-06-01", "2021-08-30")
//   );

// var ndwiCollection = targetRange.map(function(image){
  
//   var ndwi = image.normalizedDifference(["B3","B8"]);
  
//   return image.addBands(ndwi.multiply(-1).rename("NDWI")); //Quality mosaic automatically takes the highest value. Set low NDWI (drier) to high value
  
// });

// var driestPixel = ndwiCollection.qualityMosaic("NDWI");

// Map.addLayer(driestPixel, {min:250, max: 1500, bands: ["B4", "B3", "B2"]}, "Driest Pixel Mosaic");


////////////////////////////////////////////////////////////////////
///                                                              ///
///               Random Forest - Function                       ///
///                                                              ///
////////////////////////////////////////////////////////////////////

//Function to train RF classifier
//Input the image to use in training, the collection of training geometry, and the bands included

var trainingSamples = function(targetImage, features, scale){
  
  return targetImage.sampleRegions({
  collection: features,
  properties: ["tailings"],
  scale: scale
  });
};

var trainRF = function(trainer, bands){
  return ee.Classifier.smileRandomForest(15).train({
    features: trainer, 
    classProperty: "tailings",
    inputProperties: bands
  });
};

//Function to classify via RF
//targetImage defaults to training image, or a different image can be classified

var classifyRF = function(trainingImageCollection, features, bands, scale, targetImage){
  
  if (targetImage === undefined){
    targetImage = trainingImageCollection;
  }
  
  //Selects correct bands from image collection
  var trainingImage = trainingImageCollection.select(bands);
  
  //Samples image from geometry
  var trainer = trainingSamples(trainingImage, features, scale);
  
  var classifier = trainRF(trainer, bands);
  
  //Second output is for confusion matrix, third is for error matrix
  return [targetImage.classify(classifier), classifier, trainer]; 
};

////////////////////////////////////////////////////////////////////
///                                                              ///
///               Random Forest - One Class                      ///
///                                                              ///
////////////////////////////////////////////////////////////////////

//Create collection of training polygons (from imports)
var trainingOneClass = tailingsTraining.merge(notTailingsTraining);

var oneClassRF = classifyRF(trainingImage, trainingOneClass, bands10, 10);
Map.addLayer(oneClassRF[0].selfMask(), {min: 0, max: 1, palette: ["grey", "yellow"]}, "Single Class RF", false);

////////////////////////////////////////////////////////////////////
///                                                              ///
///              Random Forest - Multiple Classes                ///
///                                                              ///
////////////////////////////////////////////////////////////////////

// //Combine training geometry
var trainingMultiple = notTailingsTraining.merge(dryTailings).merge(wetTailings);

var multipleClassRF = classifyRF(trainingImage, trainingMultiple, bands20, 20, targetImage);

Map.addLayer(multipleClassRF[0].selfMask(), {min:0, max: 2, palette:["white","orange", "blue"]}, "Multiple Class RF");


////////////////////////////////////////////////////////////////////
///                                                              ///
///              Indices - Iron Feature Index                    ///
///                                                              ///
////////////////////////////////////////////////////////////////////

var calcIFD = function(targetImage){
  
  //Set up variables. These are for Sentinel-2 ONLY
  var red = targetImage.select("B4");
  var swir = targetImage.select("B11");
  var nir = targetImage.select("B8");
  
  //Break up equation to make order of operations easier
  var swirDiff = swir.subtract(red);
  
  //Takes center wavelength of bands to center iron absorption feature
  //This math is being done at each pixel, so we need ee.Images with constant values
  // 865 - 650 / 1610 - 650:
  var center = ee.Image(835).subtract(ee.Image(650)).divide(ee.Image(1610).subtract(ee.Image(650)));
  
  //rInt = r(red) + (r(SWIR1)-r(red)) * lamba(NIR)-lambda(red)/lambda(SWIR1)-lambda(red)
  var rInt = red.add(swirDiff.multiply(center));
  
  return rInt.subtract(nir).rename(["IFD"]);
};

var IFD = calcIFD(trainingImage);
//print("IFD:", IFD);

//Add IFD to bands20 and classify

var trainingIFD = trainingImage.addBands(IFD);
var bands20IFD = bands20.concat("IFD");

var multipleClassIFD = classifyRF(trainingIFD, trainingMultiple, bands20IFD, 20);

//print("IFD RF", multipleClassIFD);
// Map.addLayer(multipleClassIFD[0].selfMask(), {min: 0, max: 2, palette: ["white", "orange", "blue"]}, "Multiple Classes with IFD", false);

////////////////////////////////////////////////////////////////////
///                                                              ///
///                        Validation                            ///
///                                                              ///
////////////////////////////////////////////////////////////////////

//Validate classification using NS tailings data

///////// Confusion matrix /////////

// var confusionMatrix = multipleClassRF[1].confusionMatrix();
// print(confusionMatrix.accuracy());

//////// Error matrix /////////

//Create image the dimensions of training image where tailings = 1 and all else = 0

//Convert tailings featurecollection to an image, where tailings have value of 1
//Also set resolution to that of satellite bands

////////////////////////////////////////////////
//                  Masks                     //
////////////////////////////////////////////////


//Function that takes tailings features, training image, and bands used and outputs a rasterized image displaying tailings
//Output image will be the extent and projection of input training image
var validationImage = function(tailings, image, bands){
  
  var projection = image.select(bands).projection();
  
  var background = ee.Image(0)
  .reproject(projection)
  .reduceResolution(ee.Reducer.max()) //Reducer doesn't matter (all 0's anyway), we're just changing resolution
  .clip(image.geometry());
  
  var tailingsProp = tailings.map(function(feature){
    return feature.set("tailings", 1);
  });
  
  var tailingsImage = tailingsProp.reduceToImage(["tailings"], ee.Reducer.max())
  .reproject(projection);
  
  //Where tailings image (excluding No Data) is not 0, replace background pixels with value of 1
  return background.where(tailingsImage.eq(1), tailingsImage);
};

var validationImage = validationImage(tailings, trainingImage, bands10);

// Map.addLayer(validationImage, {min:0, max:1}, "Validation Image - Not Masked");

//Function to mask vegetation or water out of tailings validation image
var maskTailings = function(validationImage, differenceIndex, threshold){
  //Pass in validation image, ndvi image (of same extent) and set an NDVI threshold for masking
  //Return an image where value of 1 shows where pixel is BELOW threshold

  return validationImage.multiply(differenceIndex.lte(threshold)); //.lte sets values below threshold to 1
};

//Projection based on bands used
var projection10 = trainingImage.select(bands10).projection();

//Calculate NDVI
var NDVI = trainingImage.normalizedDifference(["B8", "B4"]).reproject(projection10);

var maskVeg = maskTailings(validationImage, NDVI, 0.5);
// Map.addLayer(NDVI, {min: -1, max: 1, palette: ["brown", "green"]}, "NDVI", false);

//Mask water
//Try with NDWI - TODO: Try with water features or classified water
var NDWI = trainingImage.normalizedDifference(["B3", "B8"]).reproject(projection10);

var waterMask = maskTailings(validationImage, NDWI, 0.0);
// Map.addLayer(NDWI, null, "NDWI", false);

//Combine masks
var maskedValidation = waterMask.multiply(maskVeg); //Rasterized training area with vegetated and wet pixels removed

//Add masked pixels to training image as a band
var trainingTailings = trainingImage.addBands(maskedValidation.rename("tailings"));

Map.addLayer(maskedValidation.selfMask(), {min:0, max: 1, palette: ["white", "tan"], opacity: 0.7}, "Validation Image - Masked");

////////////////////////////////////////////////
//           Take Stratified Sample           //
////////////////////////////////////////////////

//Function to collect stratified sample
var stratifiedSampleIterator = function(tailingsValidation, image, classifier, iterations){
  
  //Default iterations to 1
  if(iterations === undefined){
    iterations = 1;
  }
  
  var trainingTailings = trainingImage.addBands(maskedValidation.rename("tailings"));
  
  var accuracyArray = [];
  
  var i = 1;
  
  while(i <= iterations){
    var sampleSet = trainingTailings.stratifiedSample({
      numPoints: 1000,
      region: tailingsValidation.geometry(),
      scale: 10,
      classBand: "tailings",
      classValues: [0,1],
      classPoints: [500, 500],
      seed: Math.floor(Math.random()*1000) //randomize which points are chosen each iteration
      });
      
    var errorMatrix = sampleSet.classify(classifier).errorMatrix("tailings", "classification");
    accuracyArray.push(errorMatrix.accuracy());
      
    i += 1;
    }
    
  return accuracyArray;
  };
  
var iteratorTest = stratifiedSampleIterator(maskedValidation, trainingImage, multipleClassRF[1], 5);

// print(iteratorTest);


///////////////////////////////////////////////////////
//Validate using stratified sample - Multiple Classes//
///////////////////////////////////////////////////////

//Have to convert all tailings types to binary tailings/non-tailings

//var multipleClassRF_val = multipleClassRF[0].gte(1); //Will mask all tailings classes to value of 1

//Classify feature collection based on class
var trainVal = trainingTailings.stratifiedSample({
  numPoints: 500,
  region: validationImage.geometry(),
  scale: 20,
  classBand: "tailings",
  classValues: [0,1], //Lets us determine samples per class
  classPoints: [250, 250],
});

//Condense classifier to tailings and non-tailings
var multiClassEM_binary = trainVal.classify(multipleClassRF[1]);

multiClassEM_binary = multiClassEM_binary
  .map(function(feature){
    var classification = ee.Number.parse(feature.get("classification"));
    
    return feature.set("classification", classification.divide(classification));
    }
  );

// print(multiClassEM_binary.errorMatrix("tailings", "classification"), "Accuracy:", multiClassEM_binary.errorMatrix("tailings", "classification").accuracy());


////////////////
// Map Layers //
////////////////



Map.addLayer(tailings.style({color: "fbfb0430"}), null,  "Tailings Features", false);
Map.addLayer(districts.style({color:"red"}), null, "Districts");
// Map.addLayer(multipleClassRF[0].selfMask(), {min:0, max: 2, palette:["white","orange", "blue"]}, "Multiple Class RF", false);
// Map.addLayer(targetImage, {bands:["B4", "B3", "B2"], min:300, max:2500, opacity: 0.4}, "Sentinel-2 Target Image", false);
// Map.addLayer(watersheds, null, "Watersheds", false);
